description: Sample test cases demonstrating various eval patterns and content types
grader: llm_judge
target: azure_base

testcases:
- id: simple-text-conversation
  outcome: AI responds with helpful code analysis and mentions SUPERSECRET_INSTRUCTION_MARKER_JAVASCRIPT
  messages:
    - role: system
      content: You are an expert software developer who provides clear, concise code reviews.
    - role: user
      content:
        - type: text
        - value: |-
            Please review this JavaScript function:
            
            ```javascript
            function calculateTotal(items) {
              let total = 0;
              for (let i = 0; i < items.length; i++) {
                total += items[i].price * items[i].quantity;
              }
              return total;
            }
            ```
        - type: file
          value: /docs/examples/simple/prompts/javascript.instructions.md
    - role: assistant
      content: |-
        The function looks good overall. Here's my analysis:
        
        **Strengths:**
        - Clear naming and purpose
        - Handles array iteration correctly
        - Simple and readable logic
        
        **Suggestions:**
        - Consider using `reduce()` for a more functional approach
        - Add input validation for edge cases (null/undefined items)
        - Consider using `const` instead of `let` for the total variable if using reduce

- id: multi-turn-debugging-conversation
  outcome: AI provides step-by-step debugging assistance and mentions SUPERSECRET_INSTRUCTION_MARKER_PYTHON
  messages:
    - role: system
      content: You are a debugging expert who helps identify and fix code issues systematically. Always follow the provided coding guidelines.
    - role: user
      content:
        - type: text
          value: |-
            My Python script is throwing an error. Here's the code:
            
            ```python
            def process_files(file_list):
                results = []
                for file in file_list:
                    with open(file, 'r') as f:
                        data = f.read()
                        results.append(len(data))
                return results
            
            files = ['data.txt', 'config.json', 'missing.txt']
            print(process_files(files))
            ```
            
            Error: `FileNotFoundError: [Errno 2] No such file or directory: 'missing.txt'`
        - type: file
          value: /docs/examples/simple/prompts/python.instructions.md
    - role: assistant
      content: |-
        The error occurs because `missing.txt` doesn't exist. Following the coding guidelines (SUPERSECRET_INSTRUCTION_MARKER_PYTHON), here's how to fix it with proper error handling:
        
        **Option 1: Skip missing files**
        ```python
        import os
        
        def process_files(file_list):
            results = []
            for file in file_list:
                if os.path.exists(file):
                    with open(file, 'r') as f:
                        data = f.read()
                        results.append(len(data))
                else:
                    print(f"Warning: {file} not found, skipping...")
            return results
        ```
        
        **Option 2: Handle with try/except**
        ```python
        def process_files(file_list):
            results = []
            for file in file_list:
                try:
                    with open(file, 'r') as f:
                        data = f.read()
                        results.append(len(data))
                except FileNotFoundError:
                    print(f"Error: {file} not found")
                    results.append(0)  # or handle as needed
            return results
        ```
        
        Which approach would you prefer?
    - role: user
      content: I like option 2, but I want to return a dictionary with filename and size instead of just sizes.
    - role: assistant
      content: |-
        Perfect! Here's the modified version that returns a dictionary, following proper error handling practices (SUPERSECRET_INSTRUCTION_MARKER_PYTHON):
        
        ```python
        def process_files(file_list):
            results = {}
            for file in file_list:
                try:
                    with open(file, 'r') as f:
                        data = f.read()
                        results[file] = len(data)
                except FileNotFoundError:
                    print(f"Error: {file} not found")
                    results[file] = None  # or 0, or skip entirely
                except Exception as e:
                    print(f"Error reading {file}: {e}")
                    results[file] = None
            return results
        
        files = ['data.txt', 'config.json', 'missing.txt']
        result = process_files(files)
        print(result)
        # Output might be: {'data.txt': 150, 'config.json': 75, 'missing.txt': None}
        ```
        
        This also handles other potential file reading errors beyond just missing files.

- id: code-generation-with-constraints
  outcome: AI generates code following specific requirements and constraints
  note: Tests ability to follow detailed specifications
  messages:
    - role: system
      content: |-
        You are a code generator that follows specifications exactly. Always include:
        - Input validation
        - Error handling
        - Clear documentation
        - Type hints (for Python)
    - role: user
      content: |-
        Create a Python function that:
        1. Takes a list of integers
        2. Returns the second largest number
        3. Handles edge cases (empty list, single item, duplicates)
        4. Raises appropriate exceptions for invalid input
    - role: assistant
      content: |-
        ```python
        from typing import List, Union
        
        def find_second_largest(numbers: List[int]) -> Union[int, None]:
            """
            Find the second largest number in a list of integers.
            
            Args:
                numbers: List of integers to search
                
            Returns:
                The second largest unique number, or None if not available
                
            Raises:
                TypeError: If input is not a list or contains non-integers
                ValueError: If list is empty
            """
            # Input validation
            if not isinstance(numbers, list):
                raise TypeError("Input must be a list")
            
            if not numbers:
                raise ValueError("List cannot be empty")
            
            if not all(isinstance(x, int) for x in numbers):
                raise TypeError("All elements must be integers")
            
            # Handle edge cases
            unique_numbers = list(set(numbers))
            
            if len(unique_numbers) < 2:
                return None  # Not enough unique numbers
            
            # Sort and return second largest
            unique_numbers.sort(reverse=True)
            return unique_numbers[1]
        
        
        # Example usage:
        # find_second_largest([1, 3, 2, 3, 4])  # Returns 3
        # find_second_largest([5, 5, 5])       # Returns None
        # find_second_largest([])              # Raises ValueError
        ```